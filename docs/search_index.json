[["index.html", "Avance de Tesis Capítulo 1 Introducción", " Avance de Tesis Denis Berroeta González (denis.berroeta@uai.cl) Universidad Adolfo Ibáñez 2022-08-17 Capítulo 1 Introducción Este documento tiene la única finalidad de ir registrando los avances de tesis, conservando la estructura de un documento. En desarrollo… "],["m_teorico.html", "Capítulo 2 Marco Teórico 2.1 Modelos Armónicos 2.2 Definición de Conceptos", " Capítulo 2 Marco Teórico 2.1 Modelos Armónicos 2.1.1 Quantifying the Response of German Forests to Drought Events via Satellite Imagery (Philipp, Wegmann, and Kübert-Flock 2021) Resumen: Los sistemas forestales desempeñan funciones ecosistémicas cruciales para nuestro entorno, como el equilibrio de las reservas de carbono y la influencia en el clima local, regional y mundial. La tendencia al aumento de la frecuencia de los fenómenos meteorológicos extremos inducidos por el cambio climático, incluida la sequía, supone un gran reto para la gestión forestal. En este contexto, la aplicación de los datos de teledetección proporciona un poderoso medio para realizar investigaciones rápidas, operativas y baratas a grandes escalas espaciales y temporales. Este estudio se dedicó a explorar el potencial de los datos de satélite en combinación con los análisis armónicos para cuantificar la respuesta de la vegetación a los eventos de sequía en los bosques alemanes. El método de modelización armónica se comparó con un enfoque de estandarización z-score y se correlacionó con datos meteorológicos y topográficos. Se utilizaron imágenes ópticas de satélite de Landsat y del espectrorradiómetro de imágenes de resolución moderada (MODIS) en combinación con tres índices de vegetación comúnmente aplicados. Las puntuaciones de correlación más altas basadas en la técnica de modelización armónica se calcularon para el 6º grado armónico. Las imágenes MODIS en combinación con el Índice de Vegetación de Diferencia Normalizada (NDVI) generaron los mejores resultados para medir la respuesta espectral a las condiciones de sequía. La mayor correlación entre los datos de teledetección y las medidas meteorológicas se observó en el caso de la humedad del suelo y el Índice de Severidad de la Sequía de Palmer autocalibrado (scPDSI). Además, se identificó que las regiones forestales sobre suelos arenosos con pinos como tipo de árbol dominante eran especialmente vulnerables a la sequía. Además, los análisis topográficos sugirieron que los efectos de la sequía estaban mitigados a lo largo de las laderas de las colinas. Si bien los enfoques propuestos proporcionan información valiosa sobre la dinámica de la vegetación como respuesta a las condiciones meteorológicas, se requieren mediciones in situ estandarizadas en escalas espaciales mayores y relacionadas con la cuantificación de la sequía para una evaluación de calidad más profunda de los métodos y datos utilizados. 2.2 Definición de Conceptos 2.2.1 NDVI por completar…. \\[\\begin{equation} NDVI=\\frac{NIR-RED}{NIR+RED}\\tag{2.1} \\end{equation}\\] Figura 2.1: Descripción de valores NDVI References "],["explo.html", "Capítulo 3 Exploración de Datos 3.1 Exploración de Datos 3.2 Limpieza de Datos 3.3 Interpolación de Datos 3.4 Visualización de áreas de estudio 3.5 Aplicación Web de visualización de series", " Capítulo 3 Exploración de Datos 3.1 Exploración de Datos Se recibieron dos bases de datos en formato csv que corresponde a registros valores NDVI (2.1) en diferentes localidades que se dividen en “disturbed” y “no_disturbed”, que cooresponde si ha sido intervenidos por acción humana. Los datos están ordendos por fecha que van de 2000-01-03 a 2022-04-29. Notas: Confirmar si los valores correponden valores aleatorios de una parcela o el promedio de un área de estudio. Solicitar información que tipo de área de estudio, y coordenadas para tener mayor referencia espacial. 3.2 Limpieza de Datos Librerías library(dplyr) library(purrr) library(readr) Funciones Propias # función para extraer nombres de archivos sin la extensión extract_names &lt;- function(path, extension = &quot;csv&quot;, str_delete, str_add = &quot;f_&quot;){ list.files(path = path, pattern = paste0(&quot;*.&quot;, extension, &quot;$&quot;), full.names = F) %&gt;% gsub(str_delete, str_add, x = .) %&gt;% gsub(paste0(&quot;*.&quot;, extension, &quot;$&quot;), &quot;&quot;, x = .) } 3.2.1 Estructura a Archivos Disturbed 3.2.1.1 Lectura de todos los archivos CSV #leer todos los archivos csv con programación funcional disturbed &lt;- list.files(path = &quot;data/raw/disturbed&quot;, pattern = &quot;*.csv$&quot;, full.names = T) %&gt;% purrr::map(read_csv) %&gt;% #leer archivos purrr::map(~rename(., id = &quot;...1&quot;)) # crear id Tabla 3.1: Primeros 10 registros de Base ‘distubed’ id date ndvi 1353 2000-01-03 NA 909 2000-01-11 0.536 189 2000-01-18 0.537 569 2000-01-26 0.523 910 2000-01-27 NA 190 2000-02-03 0.480 570 2000-02-11 0.453 191 2000-02-19 NA 1354 2000-02-20 0.422 911 2000-02-28 0.423 3.2.1.2 Agregar nombres a las listas # agregar nombres a las listas names_disturbed &lt;- extract_names(path = &quot;data/raw/disturbed/&quot;, str_delete = &quot;defo_00000000000000000&quot;) head(names_disturbed) ## [1] &quot;f_000&quot; &quot;f_001&quot; &quot;f_002&quot; &quot;f_003&quot; &quot;f_004&quot; &quot;f_005&quot; names(disturbed) &lt;- names_disturbed 3.2.1.3 Agregar información de origen a la tabla de contenido disturbed &lt;- disturbed %&gt;% names(.)%&gt;% purrr::map(~mutate(disturbed[[.]], serie = .)) # combinar todo en un dataframe disturbed_df &lt;- do.call(rbind, disturbed) Tabla 3.2: Primeros 10 registros de Base ‘distubed’ id date ndvi serie 1353 2000-01-03 NA f_000 909 2000-01-11 0.536 f_000 189 2000-01-18 0.537 f_000 569 2000-01-26 0.523 f_000 910 2000-01-27 NA f_000 190 2000-02-03 0.480 f_000 570 2000-02-11 0.453 f_000 191 2000-02-19 NA f_000 1354 2000-02-20 0.422 f_000 911 2000-02-28 0.423 f_000 3.2.1.4 Guardar los resultados en RDS # Base completa saveRDS(disturbed, &quot;data/rds/disturbed_list.rds&quot;) saveRDS(disturbed_df, &quot;data/rds/disturbed_df.rds&quot;) 3.2.2 Estructura a Archivos non_disturbed 3.2.2.1 Lectura de todos los archivos CSV #leer todos los archivos csv con programación funcional non_disturbed &lt;- list.files(path = &quot;data/raw/non-disturbed/&quot;, pattern = &quot;*.csv$&quot;, full.names = T) %&gt;% purrr::map(read_csv) %&gt;% #leer archivos purrr::map(~rename(., id = &quot;...1&quot;)) # crear id Tabla 3.3: Primeros 10 registros de Base ‘non_distubed’ id date ndvi 1289 2000-01-03 0.719 407 2000-01-11 0.811 851 2000-01-11 0.812 852 2000-01-27 0.802 408 2000-01-27 0.804 1290 2000-02-20 0.748 853 2000-02-28 0.824 409 2000-02-28 0.824 1291 2000-03-07 0.663 854 2000-03-15 0.811 3.2.2.2 Agregar nombres a las listas # agregar nombres a las listas names_non_disturbed &lt;- extract_names(path = &quot;data/raw/non-disturbed/&quot;, str_delete = &quot;defo_00000000000000000&quot;) names(non_disturbed) &lt;- names_non_disturbed head(names_non_disturbed) ## [1] &quot;f_000&quot; &quot;f_001&quot; &quot;f_002&quot; &quot;f_003&quot; &quot;f_004&quot; &quot;f_005&quot; 3.2.2.3 Agregar información de origen a la tabla de contenido # no_disturbed non_disturbed &lt;- non_disturbed %&gt;% names(.)%&gt;% map(~mutate(non_disturbed[[.]], serie = .)) # combinar todo en un dataframe non_disturbed_df &lt;- do.call(rbind, non_disturbed) Tabla 3.4: Primeros 10 registros de Base ‘non_distubed’ id date ndvi serie 1289 2000-01-03 0.719 f_000 407 2000-01-11 0.811 f_000 851 2000-01-11 0.812 f_000 852 2000-01-27 0.802 f_000 408 2000-01-27 0.804 f_000 1290 2000-02-20 0.748 f_000 853 2000-02-28 0.824 f_000 409 2000-02-28 0.824 f_000 1291 2000-03-07 0.663 f_000 854 2000-03-15 0.811 f_000 3.2.2.4 Guardar los resultados en RDS # Base completa saveRDS(non_disturbed, &quot;data/rds/non_disturbed_list.rds&quot;) saveRDS(non_disturbed_df, &quot;data/rds/non_disturbed_df.rds&quot;) 3.3 Interpolación de Datos 3.3.1 Lectura de Datos disturbed_ls &lt;- readRDS(&quot;data/rds/disturbed_list.rds&quot;) no_disturbed_ls &lt;- readRDS(&quot;data/rds/non_disturbed_list.rds&quot;) 3.3.2 Interpolación Lineal # interpolación lineal ---------------------------------------------------- disturbed_ls_i &lt;- disturbed_ls %&gt;% map(~mutate(., ndvi_interpolated = imputeTS::na_interpolation(ndvi, option = &quot;linear&quot;))) no_disturbed_ls_i &lt;- no_disturbed_ls %&gt;% map(~mutate(., ndvi_interpolated = imputeTS::na_interpolation(ndvi, option = &quot;linear&quot;))) Tabla 3.5: Primeros 10 registros de Base ‘distubed’ interpolado id date ndvi serie ndvi_interpolated 1353 2000-01-03 NA f_000 0.536 909 2000-01-11 0.536 f_000 0.536 189 2000-01-18 0.537 f_000 0.537 569 2000-01-26 0.523 f_000 0.523 910 2000-01-27 NA f_000 0.502 190 2000-02-03 0.480 f_000 0.480 570 2000-02-11 0.453 f_000 0.453 191 2000-02-19 NA f_000 0.437 1354 2000-02-20 0.422 f_000 0.422 911 2000-02-28 0.423 f_000 0.423 3.3.3 Guardar los Resultados # Guardar Resultados ------------------------------------------------------ # disturbed saveRDS(disturbed_ls_i, &quot;data/rds/disturbed_i_list.rds&quot;) #lista disturbed_i_df &lt;- do.call(rbind, disturbed_ls_i) #dataframe saveRDS(disturbed_i_df, &quot;data/rds/disturbed_i_df.rds&quot;) write.csv(disturbed_i_df, &quot;data/csv/disturbed_i_df.csv&quot;) # non disturbed saveRDS(no_disturbed_ls_i, &quot;data/rds/non_disturbed_i_list.rds&quot;) #lista no_disturbed_i_df &lt;- do.call(rbind, no_disturbed_ls_i) # dataframe saveRDS(no_disturbed_i_df, &quot;data/rds/non_disturbed_i_df.rds&quot;) write.csv(no_disturbed_i_df, &quot;data/csv/non_disturbed_i_df.csv&quot;) 3.4 Visualización de áreas de estudio 3.4.1 Disturbed Espacial 3.4.1.1 Lectura de gwf_forests.shp *Disturbed” #leer todos los archivos csv con programación funcional disturbed_sf &lt;- st_read(&quot;data/raw/disturbed/IWD_Deforested.shp&quot;, quiet=T) 3.4.1.2 Agregar Key para conectar con Series disturbed_sf &lt;- disturbed_sf %&gt;% mutate(serie = substr(id, start = (nchar(id)-2), stop = nchar(id))) %&gt;% mutate(serie = paste0(&quot;f_&quot;, serie)) 3.4.1.3 Visualización Mapa Disturbed 3.4.1.4 Guardar Objeto Espacial saveRDS(disturbed_sf, file = &quot;data/rds/disturbed_sf.rds&quot;) st_write(disturbed_sf, &quot;data/shapes/disturbed_sf.shp&quot;, delete_dsn = T) 3.4.2 Non_disturbed Espacial 3.4.2.1 Lectura de gwf_forests.shp *Disturbed” #leer todos los archivos csv con programación funcional non_disturbed_sf &lt;- st_read(&quot;data/raw/non-disturbed/gwf_forests.shp&quot;, quiet=T) 3.4.2.2 Agregar Key para conectar con Series No se puede no tiene variable ID 3.4.2.3 Visualización Mapa Non_disturbed 3.4.2.4 Guardar Objeto Espacial saveRDS(non_disturbed_sf, file = &quot;data/rds/non_disturbed_sf.rds&quot;) st_write(non_disturbed_sf, &quot;data/shapes/non_disturbed_sf.shp&quot;, delete_dsn = T) 3.5 Aplicación Web de visualización de series Para una visualización completa de las dos series de tiempo se creó una aplicación web con stramlit (librería de python) Figura 3.1: Aplicación para visualizar la serie de tiempo (Berroeta, Denis 2022) Link de la aplicación web: https://denissebastian-app-ts-app-5ud0c1.streamlitapp.com References "],["exp.html", "Capítulo 4 Experimentación 4.1 rHarmonics", " Capítulo 4 Experimentación En este capítulo se expondrá todos los experimentos con su respectiva documentación, representado en un subtítulo aparte. A continuación se señalan experimentos realizados: rHarmonics 4.1 4.1 rHarmonics 4.1.1 Antecedentes Definición de la estacionalidad por píxeles basada en un modelo armónico Para cada píxel se ajusta un modelo armónico basado en un periodo de tiempo, considerado como representativo de un comportamiento estacional “normal” del índice de vegetación para el caso estudiado. Para calcular la curva armónica ajustada de una señal periódica, se calculan regresiones por mínimos cuadrados ordinarios utilizando curvas de seno y coseno acopladas sobre datos de series temporales. El algoritmo subyacente que se basa en la siguiente ecuación (Shumway and Stoffer 2017) \\[\\begin{equation} X_t=\\beta_0+\\beta_1\\cdot2\\pi t + \\sum_{i=1}^{n}(\\beta_{2i}\\cdot\\cos(\\frac{i2\\pi t}{T})\\cdot \\beta_{3i}\\cdot\\sin(\\frac{i2\\pi t}{T})) \\tag{4.1} \\end{equation}\\] Donde: \\(t\\) = Diferencia de tiempo en años fractales desde el 1 de enero de 1970 \\(T\\) = Duración del periodo de tiempo (un año) \\(n\\) = Número total de armónicos \\(i\\) = armónicos actuales \\(\\beta_x\\) = Coeficientes independientes derivados de la regresión OLS Figura 4.1: MODIS NDVI time-series data together with a harmonic fitted curve using 3 cylces per year. 4.1.2 Experimentación: R package for harmonic modelling of time-series data Para la siguiente experimentación se tomo en cuenta la siguiente trabajo como referencia, que es el caso de ejemplo de uso de la librería (“R Package for Harmonic Modelling of Time-Series Data - Remote Sensing News” 2020) Lectura de Datos Para este ejemplo se utilizará la base de datos de los registros de NDVI, que fueron abordados en capítulo de Exploración de Datos 3. En específico se usarán los datos correspodientes a disturbed (intervenidos) que fueron interpolados. # Lectura de Insumos ------------------------------------------------------ disturbed_int &lt;- read.csv2(&quot;data/csv/disturbed_i_df.csv&quot;, sep = &quot;,&quot;,check.names=F) %&gt;% select(date:ncol(.)) %&gt;% mutate(date = as.Date(date)) Tabla 4.1: Primeros 10 registros de Base ‘distubed’ date ndvi serie ndvi_interpolated 2000-01-03 NA f_000 0.536480763960968 2000-01-11 0.536480763960968 f_000 0.536480763960968 2000-01-18 0.536712633479725 f_000 0.536712633479725 2000-01-26 0.523019573092461 f_000 0.523019573092461 2000-01-27 NA f_000 0.501607045666738 2000-02-03 0.480194518241015 f_000 0.480194518241015 2000-02-11 0.452820640802383 f_000 0.452820640802383 2000-02-19 NA f_000 0.437368883057074 2000-02-20 0.421917125311765 f_000 0.421917125311765 2000-02-28 0.423424304073507 f_000 0.423424304073507 Los datos de la columna ndvi_interpolated seràn los que se utilizarán para la prueba. La tabla filtrada tiene la siguiente dimensión 164499, 4 Selección de una Serie ndvi_df &lt;- disturbed_int %&gt;% filter(serie == &quot;f_015&quot;) %&gt;% select(date, ndvi = ndvi_interpolated) %&gt;% mutate(ndvi = as.numeric(ndvi)) Confirmar si los valores correponden valores aleatorios de una parcela o el promedio de un área de estudio. Solicitar información que tipo de área de estudio, y coordenadas para tener mayor referencia espacial. Aplicación Función harmonics_fun() # Apply harmonic function using 1 cycles per year fitted_3rd_deg &lt;- harmonics_fun(user_vals = ndvi_df$ndvi, user_dates = ndvi_df$date, harmonic_deg = 1) fitted_3rd_deg %&gt;% head(10) ## [1] 0.5672291 0.5644079 0.5644079 0.5628282 0.5620696 0.5620541 0.5620541 ## [8] 0.5624409 0.5639354 0.5665252 La función anterior, genera un vector con los datos ajustado por función armónica, de largo igual a la cantidad de registros de la serie (2276) Consolidar una Tabla # Combine fitted values with original df combined_df &lt;- cbind(ndvi_df, fitted_3rd_deg) names(combined_df) &lt;- c(&quot;dates&quot;, &quot;ndvi&quot;, &quot;fitted&quot;) Visualización de Resultados p &lt;- ggplot2::ggplot() + geom_point(data=combined_df, aes(x = dates, y = ndvi), color=&#39;gray50&#39;, size=1) + geom_line(data=combined_df, aes(x = dates, y = fitted), colour = &quot;orange&quot;, size=1)+ labs(title=&quot;NDVI TimeSeries with fitted values&quot;, x=&quot;Date&quot;, y=&quot;NDVI&quot;) + theme(plot.title = element_text(hjust = 0.5, face=&quot;bold&quot;, size=14), axis.text=element_text(size=10), axis.title=element_text(size=12), legend.title=element_text(size=13, face=&quot;bold&quot;), legend.text=element_text(size=13))+ ylim(0,1)+ theme_bw() ggplotly(p) Conclusiones Como se observaen la visualización anterior la modelo armónico no se ajusta a los datos, por lo cual se tiene que investigar para encontrar los parámetros del modelo que permitan que los valores predichos por modelo se austen a los datos reales. Se puede probar eliminando los valores outliers o interpolarlos. References "],["referencias.html", "Capítulo 5 Referencias", " Capítulo 5 Referencias "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
